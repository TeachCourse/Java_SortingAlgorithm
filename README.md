## 1、冒泡排序算法

将一个数组的元素两两比较，将大的元素交换位置并逐渐“上浮”到右边

定义一个需要排序的数组：`int num[]={4,6,2,5,8,9}`

---
**第一趟：** 找到数组`{4,6,2,5,8,9}`最大的元素并“上浮”到右边

指针位置为0，4和6比较，4小于6，不需要交换位置

无序数组,：`{4,6,2,5,8,9}`

指针位置为1，6和2比较，6大于2，交换位置

无序数组：`{4,[2],[6],5,8,9}`

指针位置为2：6和5比较，6大于5，交换位置

无序数组：`{4,2,[5],[6],8,9}`

指针位置为3，6和8比较，6小于8，不需要交换位置

无序数组：`{4,2,5,6,8,9}`

指针位置为4，8和9比较，8小于9，不需要交换位置

无序数组：`{4,2,5,6,8,9}`

---
**第二趟：** 找到数组`{4,2,5,6,8,9}`最大的元素并“上浮”到右边

指针位置为0，4和2比较，4大于2，交换位置

无序数组：`{[2],[4],5,6,8,9}`

指针位置为1，4和5比较，4小于5，不需要交换位置

无序数组：`{2,4,5,6,8,9}`

指针位置为2，5和6比较，5小于6，不需要交换位置

无序数组：`{2,4,5,6,8,9}`

指针位置为3，6和8比较，6小于8，不需要交换位置

无序数组：`{2,4,5,6,8,9}`

指针位置为4，8和9比较，8小于9，不需要交换位置

无序数组：`{2,4,5,6,8,9}`

---
同理，程序依次执行

第三趟...

第四趟...

第五趟...

---
对于一个长度为N的数组，需要执行（N-1）趟，每一趟需要比较次数分别为：`N-1,N-2,N-3...3,2,1`

用*C*表示比较次数，用*M*表示移动次数

最坏的时间复杂度：*一个逆序的数组*

`$C_{max}=\frac{[(n-1)+1](n-1)}2=\frac{n(n-1)}2=O(n^2)$`

`$M_{max}=\frac{3[(n-1)+1](n-1)}2=\frac{3n(n-1)}2=O(n^2)$`

```java
	int num[] = { 4, 6, 2, 5, 8, 9 };

	for (int i = 0; i < num.length-1; i++) {
		int tmp;// 临时变量
		for (int j = 0; j < num.length-1; j++) {
			if (num[j] > num[j + 1]) {
				tmp = num[j];
				num[j] = num[j + 1];
				num[j + 1] = tmp;
			}
		}
	}

	for (int i = 0; i < num.length; i++) {
		System.out.println("num[" + i + "]=" + num[i]);
	}
```

> [百度百科：冒泡排序](https://baike.baidu.com/item/冒泡排序/4602306)

> [Java中的经典算法之冒泡排序(Bubble Sort)](https://www.cnblogs.com/shen-hua/p/5422676.html)

### [例子源码](src/cn/teachcourse/SortOfBubble.java)


## 2、插入排序算法

插入排序算法将数组分为：有序数组和无序数组，依次将无序数组的元素插入到有序数组中合适的位置，完成排序状态

定义数组：`int num={4,2,5,1,9,8,6}`，将数组划分：

有序数组为`{4}`

无序数组为`{2,5,1,9,8,6}`

依次将无序数组的元素插入到合适的位置：

---
**第一趟：** 将2插入到有序数组合适的位置

2和4比较，2小于4，将4往右边移动，腾出了一个空位

有序数组为：`{[],4}`

无序数组为：`{5,1,9,8,6}`

因为空位的左边没有其他的元素，所以将元素2插入到空位中

有序数组为：`{2,4}`

无序数组为：`{5,1,9,8,6}`

---
**第二趟：** 将5插入到有序数组合适的位置

5和4比较，5大于4，不移动位置

5和2比较，5大于2，不移动位置

所以将5直接插入有序数组最右边位置

有序数组为：`{2,4,5}`

无序数组为：`{1,9,8,6}`

---
**第三趟：** 将1插入到有序数组合适的位置

1和5比较，1小于5，将5往右边移动，腾出一个空位

有序数组：`{2,4,[],5}`

无序数组：`{9,8,6}`

1和4比较，1小于4，将4往右边移动，腾出一个空位

有序数组：`{2,[],4,5}`

无序数组：`{9,8,6}`

1和2比较，1小于2，将2往右边移动，腾出一个空位

有序数组：`{[],2,4,5}`

无序数组：`{9,8,6}`

因为空位的左边没有其他的元素，所以将元素1插入到空位中

有序数组：`{1,2,4,5}`

无序数组：`{9,8,6}`

---
**第四趟：** 将9插入到有序数组合适的位置

9和5比较，9大于5，不移动位置

9和4比较，9大于4，不移动位置

9和2比较，9大于2，不移动位置

9和1比较，9大于1，不移动位置

所以将9直接插入有序数组最右边位置

有序数组：`{1,2,4,5,9}`

无序数组：`{8,6}`

---

**第五趟：** 将8插入到有序数组合适的位置

8和9比较，8小于9，将9往右边移动，腾出一个空位

有序数组：`{1,2,4,5,[],9}`

无序数组：`{6}`

8和5比较，8大于5，不移动位置，将8插入腾出的空位

有序数组：`{1,2,4,5,8,9}`

无序数组：`{6}`

---
**第六趟：** 将6插入到有序数组合适的位置

6和9比较，6小于9，将9往右边移动，腾出一个空位

有序数组：`{1,2,4,5,8,[],9}`

有序数组：`{}`

6和8比较，6小于8，将8往右边移动，腾出一个空位

有序数组：`{1,2,4,5,[],8,9}`

无序数组：`{}`

6和5比较，6大于5，不移动位置

所以将6插入到腾出的空位

有序数组：`{1,2,4,5,6,8,9}`

有序数组：`{}`

---
**结束：** 无序数组已经全部插入到有序数组中，排序完成，Java代码实现插入排序算法

```java
	int num[] = { 4, 2, 5, 1, 9, 8, 6 };
	int j;// 记录左边元素的下标
	for (int i = 1; i < num.length; i++) {
		int tmp = num[i];// 记录插入有序数组的元素

		for (j = i; j > 0 && tmp < num[j - 1]; j--) {
			num[j] = num[j - 1];// 将元素往右边移动
		}
		// 跳出了循环，说明找到了元素插入的位置并插入
		num[j] = tmp;
	}
	//遍历排序好的数组num
    int p=0;
	for (int i : num) {
		System.out.println("num["+p+"]="+i);
		p++;
	}
```

分析：

一个长度为N的数组，需要执行N-1趟循环，每一趟循环需要比较的次数分别为：`1,2,3...(n-1)`，用*C*表示比较的次数

最坏的情况下是一个逆序

`$C_{max}=\frac{[(n-1)+1](n-1)}2=\frac{n(n-1)}2=O(n^2)$`

### [例子源码](src/cn/teachcourse/SortOfInSertion.java)


## 3、快速排序算法

选中一个基准元素，用j表示从右边往左边移动的数组下标，用i表示从左边往右边移动的数组下标

从右边往左边移动时，把j对应的数组元素和基准元素比较，将小于基准元素的值移动到左边

同理，从左边往右边移动时，把i对应的数组元素和基准元素比较，将大于基准元素的值移动到右边

最终，i总会遇到j，记录i的值，重复上述步骤

**例子说明：**

现在定义一个数组：`int num[]={3, 2, 5, 1, 8, 0, 6}`

**第一趟：** 选一个基准元素，比如`num[0]=3`，j从下标6开始，i从下标0开始，把满足条件的元素移动位置

*开始于右边比较*

`j=6`，即`num[6]=6`，不移动位置（右边元素小于基准元素，移动位置，否则不移动）

`j=5`，即`num[5]=0`，0小于3，移动位置（将num[5]移动到num[0]所在位置），腾出一个空位

数组：`{0, 2, 5, 1, 8, [], 6}`

*左边比较*

`i=0`，即`num[0]=0`，0小于3，不移动位置（左边元素大于基准元素，移动位置，否则不移动）

`i=1`，即`num[1]=2`，2小于3，不移动位置

`i=2`，即`num[2]=5`，5大于3，移动位置（将num[2]移动到空位中），腾出一个空位

数组：`{0, 2, [], 1, 8, 5, 6}`

*右边比较*

`j=4`，即`num[4]=8`，8大于3，不移动位置

`j=3`，即`num[3]=1`，1小于3，移动位置，移动到空位中

数组：`{0, 2, 1, [], 8, 5, 6}`

*左边比较*

`i=3`，同时`j=3`，i和j相遇，将基准元素放入空位中，并记录当前相遇的数组下标为*3*

数组：`{0, 2, 1, [3], 8, 5, 6}`

**第二趟：** 在相遇位置将数组划分为A、B两个子数组

**A数组**：`{0,2,1}`

继续比较，重复第一趟的比较过程，基准元素为`num[0]=0`

`j=2`，即`num[2]=1`，1大于0，不移动位置

`j=1`，即`num[1]=2`，2大于0，不移动位置

`j=0`，同时`i=0`，i和j相遇，并记录当前相遇的数组下标为*0*

**相遇位置将A数组划分为`$A_1$`、`$A_2$`两个子数组**

`$A_1$`数组`{0}`，j=0，同时i=0，直接将基准元素放入数组中

`$A_2$`数组`{2,1}`，继续比较，重复第一趟的比较过程，基准元素为`num[0]=2`

`j=1`，即`num[1]=1`，1小于2，移动位置

数组：`{1,[]}`

`i=0`，即`num[0]=1`，1小于2，不移动位置

`i=1`，同时`j=1`，i和j相遇，将基准元素放入腾出的为空中

数组：`{1,2}`

所以，A数组为：`{0,1,2}`

同理，

**B数组：**`{8,5,6}`

重复第一趟的比较过程，基准元素为`num[0]=8`

`j=2`，即`num[2]=6`，6小于8，移动位置

数组：`{6,5,[]}`

`i=0`，即`num[0]=6`，6小于8，不移动位置

`i=1`，即`num[1]=5`，5小于8，不移动位置

`i=2`，同时`j=2`，i和j相遇，将基准元素放入腾出的空位，并记录相遇时的数组下标*2*

数组：`{6,5,8}`

**相遇位置将B数组划分为`$B_1$`、`$B_2$`两个子数组**

`$B_1$`数组`{6,5,8}`，继续比较，重复第一趟的比较过程，基准元素为`num[0]=6`

`j=2`，即`num[2]=8`，8大于6，不移动位置

`j=1`，即`num[1]=5`，5小于6，移动位置，腾出一个空位

数组：`{5,[],8}`

`i=0`，即`num[i]=5`，5小于6，不移动位置，将基准元素放入空位

数组：`{5,6,8}`

`$B_2$`数组`{}`

所以，B数组为：`{5,6,8}`

**结束：** 最终A数组、B数组排序完成，整个数组是一个有序数组

数组：`{A,3,B}`，即`{0,1,2,3,5,6,8}`

Java代码实现快速排序算法

```java
public static void main(String args[]){
    int num[]={3, 2, 5, 1, 8, 0, 6};
    
    quickSort(num,0,num.length-1);
    
    for(int i=0;i<num.length;i++){
        System.out.println("num["+i+"]="+num[i]);
    }
}
```

```java

public void quickSort(int a[],int i,int j){
    if(i<j){
        //计算i和j相遇的数组下标
        int meet=getMiddle(a,i,j);
        //左边数组
        quickSort(a,i,meet-1);
        //右边数组
        quickSort(a,meet+1,j);
    }
}
```

```java
public int getMiddle(int a[],int i,int j){
    //选择基准元素
    int temp=a[i];
    while(i<j){
    
        //从右边开始移动数组下标
        while(i<j&&a[j]>=temp){
            j--;
        }
        //将小于基准元素的值移动位置
        a[i]=a[j];
        
        while(i<j&&a[i]<=temp){
            i++;
        }
        //将大于基准元素的值移动位置
        a[j]=a[i];
    }
    //最后将基准元素放入腾出的空位
    a[i]=temp;
    //返回相遇的数组下标
    return i;
}
```

### [例子源码](src/cn/teachcourse/SortOfQuick.java)


## 4、选择排序算法

冒泡排序算法的特点是，依次比较相邻的两个元素对象，并将大的元素往右边移动

选择排序算法的特点是，依次记录数组中最小元素的下标，并将最小元素移动到左边


现在定义数组：`int a[]={3,2,5,8,9,1}`

**第一趟：** 将数组中的最小元素移动到`i=0`的位置

用`low`记录数组最小元素的下标，初始值为`low=i=0`

3和2比较，2小于3，将元素2的下标赋值给low，即`low=1`

3和5比较，5大于3，不记录元素下标

3和8比较，8大于3，不记录元素下标

3和9比较，9大于3，不记录元素下标

3和1比较，1小于3，将元素1的下标赋值个low，即`low=5`

第一趟比较结束，将`a[low]=a[5]=1`移动到`i=0`(记录`temp=a[0]=3`)的位置

数组：`{[1],2,5,8,9,[]}`

同时，将`temp`移动到`low=5`的位置

数组：`{[1],2,5,8,9,[3]}`

**第二趟：** 将数组中的最小元素移动到`i=1`的位置

用`low`记录数组最小元素的下标，初始值为`low=i=1`

2和5比较，5大于2，不记录元素下标

2和8比较，8大于2，不记录元素下标

2和9比较，9大于2，不记录元素下标

2和3比较，3大于2，不记录元素下标

第二趟比较结束，将`a[low]=a[1]=2`移动到`i=1`(记录`temp=a[1]=2`)位置

`{1,2,5,8,9,3}`

同时，将`temp`移动到`low=1`的位置（low和i处于同一个位置）

**第三趟：** 将数组中的最小元素移动到`i=2`的位置

用`low`记录数组最小元素的下标，初始值为`low=i=2`

5和8比较，8大于5，不记录元素下标

5和9比较，9大于5，不记录元素下标

5和3比较，3小于5，将元素3的下标赋值给low，即`low=5`

第三趟比较结束，将`a[low]=a[5]=3`移动到`i=2`（记录`temp=a[2]=5`）的位置

`{1,2,[3],8,9,[]}`

同时，将`temp`移动到`low=5`的位置

`{1,2,[3],8,9,[5]}`

**第四趟：** 将数组中的最小元素移动到`i=3`的位置

用`low`记录数组最小元素的下标，初始值为`low=i=3`

8和9比较，9大于8，不记录元素下标

8和5比较，5小于8，将元素5的下标赋值给low，即`low=5`

第四趟比较结束，将`a[low]=a[5]=5`移动到`i=3`（记录`temp=a[3]=8`）的位置

`{1,2,3,[5],9,[]}`

同时，将`temp`移动到`low=5`的位置

`{1,2,3,[5],9,[8]}`

**第五趟：** 将数组中的最小元素移动到`i=4`的位置

用`low`记录数组最小元素的下标，初始值为`low=i=4`

9和8比较，8小于9，将元素8的下标赋值给low，即`low=5`

第五趟比较结束，将`a[low]=a[5]=8`移动到`i=4`(记录`temp=a[4]=9`)的位置

`{1,2,3,5,[8],[]}`

同时，将`temp`移动到`low=5`的位置

`{1,2,3,5,[8],[9]}`


**结束：** 长度为n的数组循环(n-1)次，每一趟需要比较的次数为`(n-i)`，i取值为`1<=i<=n-1`，用C表示比较的次数有：

`$C_{max}=\frac{(n-1)[1+(n-1)]}2=\frac{n(n-1)}2=O(n^2)$`

Java代码实现选择排序算法

```java
public static void main(String args[]){
    int a[]={3,2,5,8,9,1};
    
    for(int i=0;i<a.length-1;i++){
        int temp=a[i];//临时变量
        int low=i;//记录数组最小元素的下标
        for(int j=i+1;j<a.length;j++){
            if(a[i]>a[j]){
                low=j;
            }
        }
        a[i]=a[low];//将最小元素的值移动到i位置
        a[low]=temp;//将i位置的值移动到low位置
    }
    
    for(int p=0;p<a.length;p++){
        System.out.println("a["+p+"]="+a[p]);
    }
}
```

### [例子源码](src/cn/teachcourse/SortOfSelector.java)